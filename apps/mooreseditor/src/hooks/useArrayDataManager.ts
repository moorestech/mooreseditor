import { useCallback, useMemo } from 'react';
import { arrayMove } from '@dnd-kit/sortable';
import { DragEndEvent } from '@dnd-kit/core';
import type { Schema, ValueSchema, ArraySchema } from '../libs/schema/types';
import { createInitialValue } from '../utils/createInitialValue';
import { calculateAutoIncrement } from '../utils/autoIncrement';

export interface UseArrayDataManagerOptions {
  data: any[] | undefined;
  schema: { items?: Schema | ValueSchema };
  onDataChange?: (value: any[]) => void;
  useFullInitialization?: boolean; // falseの場合は全フィールドを生成（TableView用）
}

export interface UseArrayDataManagerReturn {
  arrayData: any[];
  addItem: () => void;
  removeItem: (index: number) => void;
  duplicateItem: (index: number) => void;
  handleDragEnd: (event: DragEndEvent) => void;
  items: string[]; // ドラッグ&ドロップ用のアイテムID
}

/**
 * 配列データの操作を管理するカスタムフック
 * ArrayFieldとTableViewで共通して使用される配列操作ロジックを提供
 */
export function useArrayDataManager({
  data,
  schema,
  onDataChange,
  useFullInitialization = true
}: UseArrayDataManagerOptions): UseArrayDataManagerReturn {

  const arrayData = useMemo(() => {
    if (data === undefined) return [];
    return Array.isArray(data) ? data : [];
  }, [data]);

  // ドラッグ&ドロップ用のアイテムID生成
  const items = useMemo(() => {
    return arrayData.map((_, index) => `index-${index}`);
  }, [arrayData]);

  // 新しいアイテムを追加
  const addItem = useCallback(() => {
    if (onDataChange && schema.items) {
      const newArray = [...arrayData];
      // TableViewではuseFullInitialization=false、ArrayFieldではtrue
      const defaultValue = createInitialValue(schema.items, newArray, useFullInitialization);
      newArray.push(defaultValue);
      onDataChange(newArray);
    }
  }, [arrayData, schema.items, onDataChange, useFullInitialization]);

  // アイテムを削除
  const removeItem = useCallback((index: number) => {
    if (onDataChange) {
      const newArray = [...arrayData];
      newArray.splice(index, 1);
      onDataChange(newArray);
    }
  }, [arrayData, onDataChange]);

  // アイテムを複製
  const duplicateItem = useCallback((index: number) => {
    if (onDataChange && schema.items) {
      const newArray = [...arrayData];
      const itemToDuplicate = arrayData[index];

      // ディープコピーを作成
      const duplicatedItem = structuredClone(itemToDuplicate);

      // IDを再生成した複製アイテムを作成
      const finalDuplicatedItem = regenerateIds(duplicatedItem, schema.items, newArray, index);

      // 元のアイテムの直後に挿入
      newArray.splice(index + 1, 0, finalDuplicatedItem);
      onDataChange(newArray);
    }
  }, [arrayData, schema.items, onDataChange]);

  // ドラッグ&ドロップのハンドラー
  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event;

    if (active.id !== over?.id && onDataChange) {
      const oldIndex = items.indexOf(String(active.id));
      const newIndex = items.indexOf(String(over?.id));

      const newData = arrayMove(arrayData, oldIndex, newIndex);
      onDataChange(newData);
    }
  }, [arrayData, onDataChange, items]);

  return {
    arrayData,
    addItem,
    removeItem,
    duplicateItem,
    handleDragEnd,
    items
  };
}

/**
 * UUID/autoIncrementフィールドの再生成を行うヘルパー関数
 * 複製時に新しいIDを生成するために使用
 */
function regenerateIds(
  item: any,
  itemSchema: Schema | ValueSchema,
  newArray: any[],
  currentIndex: number
): any {
  if (!itemSchema || !('type' in itemSchema)) return item;

  if (itemSchema.type === 'uuid' && itemSchema.autoGenerated) {
    return crypto.randomUUID();
  }

  if (itemSchema.type === 'object' && itemSchema.properties) {
    const newItem = { ...item };
    itemSchema.properties.forEach(prop => {
      const { key, ...propSchema } = prop;

      // UUIDの再生成
      if ('type' in propSchema && propSchema.type === 'uuid' && propSchema.autoGenerated) {
        newItem[key] = crypto.randomUUID();
      }

      // autoIncrementの再計算
      if ('type' in propSchema &&
          (propSchema.type === 'integer' || propSchema.type === 'number') &&
          propSchema.autoIncrement) {
        // 複製後の配列を仮想的に作成して計算
        const tempArray = [...newArray];
        tempArray.splice(currentIndex + 1, 0, item);
        newItem[key] = calculateAutoIncrement(
          tempArray,
          key,
          propSchema.autoIncrement
        );
      }

      // ネストされたオブジェクトや配列の処理
      if ('type' in propSchema && propSchema.type === 'object' && newItem[key]) {
        newItem[key] = regenerateIds(newItem[key], propSchema, [], 0);
      }
      if ('type' in propSchema && propSchema.type === 'array' && Array.isArray(newItem[key])) {
        newItem[key] = newItem[key].map((arrayItem: any, idx: number) =>
          regenerateIds(arrayItem, (propSchema as ArraySchema).items, newItem[key], idx)
        );
      }
    });
    return newItem;
  }

  if (itemSchema.type === 'array' && Array.isArray(item)) {
    return item.map((arrayItem: any, idx: number) =>
      regenerateIds(arrayItem, (itemSchema as ArraySchema).items, item, idx)
    );
  }

  return item;
}