# mooreseditor - Claude向け開発ガイド

## 【MUST GLOBAL】Gemini活用（プロジェクトのCLAUDE.mdより優先）

### 三位一体の開発原則
ユーザーの**意思決定**、Claudeの**分析と実行**、Geminiの**検証と助言**を組み合わせ、開発の質と速度を最大化する：
- **ユーザー**：プロジェクトの目的・要件・最終ゴールを定義し、最終的な意思決定を行う**意思決定者**
  - 反面、具体的なコーディングや詳細な計画を立てる力、タスク管理能力ははありません。
- **Claude**：高度な計画力・高品質な実装・リファクタリング・ファイル操作・タスク管理を担う**実行者**
  - 指示に対して忠実に、順序立てて実行する能力はありますが、意志がなく、思い込みは勘違いも多く、思考力は少し劣ります。
- **Gemini**：深いコード理解・Web検索 (Google検索) による最新情報へのアクセス・多角的な視点からの助言・技術的検証を行う**助言者**
  - プロジェクトのコードと、インターネット上の膨大な情報を整理し、的確な助言を与えてくれますが、実行力はありません。

### 実践ガイド
- **ユーザーの要求を受けたら即座に`gemini -p <質問内容>`で壁打ち**を必ず実施
- Geminiの意見を鵜呑みにせず、1意見として判断。聞き方を変えて多角的な意見を抽出
- Claude Code内蔵のWebSearchツールは使用しない
- Geminiがエラーの場合は、聞き方を工夫してリトライ：
  - ファイル名や実行コマンドを渡す（Geminiがコマンドを実行可能）
  - 複数回に分割して聞く

### 主要な活用場面
1. **実現不可能な依頼**: Claude Codeでは実現できない要求への対処 (例: `今日の天気は？`)
2. **前提確認**: ユーザー、Claude自身に思い込みや勘違い、過信がないかどうか逐一確認 (例: `この前提は正しいか？`）
3. **技術調査**: 最新情報・エラー解決・ドキュメント検索・調査方法の確認（例: `Rails 7.2の新機能を調べて`）
4. **設計検証**: アーキテクチャ・実装方針の妥当性確認（例: `この設計パターンは適切か？`）
5. **コードレビュー**: 品質・保守性・パフォーマンスの評価（例: `このコードの改善点は？`）
6. **計画立案**: タスクの実行計画レビュー・改善提案（例: `この実装計画の問題点は？`）
7. **技術選定**: ライブラリ・手法の比較検討 （例: `このライブラリは他と比べてどうか？`）

## プロジェクト概要
mooreseditorは、JSONデータをスキーマに基づいて編集するためのTauriアプリケーションです。

### 重要な設計原則
このプロジェクトはYAMLファイルからスキーマを動的にロードし、そのスキーマを基にJSONデータを編集するマスタデータ編集ソフトウェアです。様々な形式のスキーマが入力されることを想定しているため、**絶対にサンプルにあるようなスキーマ構造をハードコードしてはいけません**。すべてのスキーマ処理は動的に行い、汎用的な実装を心がけてください。

## 主要なコマンド

### 開発環境の起動
```bash
pnpm run tauri dev
```

### リントとタイプチェック
```bash
pnpm run lint
pnpm run typecheck
```

### テストの実行
```bash
pnpm run test
```

## Playwrightを使ったデバッグ方法

### 基本的な手順

1. **ブラウザを開く**
```
mcp__playwright__browser_navigate でhttp://localhost:1420/にアクセス
```

2. **要素をクリック**
```
mcp__playwright__browser_click で要素を選択
- element: クリックする要素の説明
- ref: スナップショットからの要素参照
```

3. **テキスト入力**
```
mcp__playwright__browser_type でテキストボックスに入力
- element: 入力する要素の説明
- ref: 要素参照
- text: 入力するテキスト
```

4. **キーボードショートカット**
```
mcp__playwright__browser_press_key でキーを押す
例: Control+s（保存）
```

5. **コンソールログの確認**
```
mcp__playwright__browser_console_messages でブラウザコンソールのメッセージを取得
- エラーの確認
- console.logの出力確認
- 保存されたデータの確認
```

### よく使うデバッグパターン

#### データ保存のテスト
1. FileOpenボタンをクリック
2. メニュー項目（mapObjects等）を選択
3. フィールドに値を入力
4. Ctrl+Sで保存
5. コンソールログで保存されたJSONを確認

#### 複数フィールドの変更確認
1. 最初のフィールドを変更して保存
2. コンソールログで確認
3. 別のフィールドを変更して保存
4. 前回の変更が保持されているか確認

### 注意点
- 開発環境（http://localhost:1420/）で実行すること
- Tauriのinvokeエラーは開発環境では無視してよい
- サンプルプロジェクトでは実際のファイル保存はスキップされる

## アーキテクチャ

### ディレクトリ構造
- `/src/components/` - UIコンポーネント
- `/src/hooks/` - カスタムフック
- `/src/utils/` - ユーティリティ関数
- `/src/libs/schema/` - スキーマ関連の型定義

### 主要なコンポーネント
- `App.tsx` - メインアプリケーション、状態管理
- `FormView` - フォーム形式でのデータ編集
- `TableView` - テーブル形式でのデータ表示
- `EditView` - 個別アイテムの編集

### データフロー
1. JSONファイルの読み込み（useJson）
2. スキーマの読み込み（useSchema）
3. FormView/TableViewでの編集
4. onDataChangeによる状態更新
5. Ctrl+Sで全データを保存

## コーディング規約

### エラーハンドリング
- 環境判定のためのif文は避け、try-catchパターンを使用する
- 本番環境のコードを先に試し、失敗した場合に開発環境用のフォールバックを実行する
- 例：
  ```typescript
  // 良い例
  try {
    // 本番環境のファイル読み込みを試行
    const content = await readTextFile(filePath);
  } catch (error) {
    // 開発環境用のフォールバック
    const content = await getSampleData();
  }
  
  // 避けるべき例
  if (isDev) {
    const content = await getSampleData();
  } else {
    const content = await readTextFile(filePath);
  }
  ```

### Playwrightを使った基本的な動作確認フロー
- http://localhost:1420にアクセス
- FileOpenボタンを押す
- サイドバーに表示されたitems, blocks, mapObjects等を押す（指示によって変わる）
- 表示されたデータに対して指定された動作を実行

