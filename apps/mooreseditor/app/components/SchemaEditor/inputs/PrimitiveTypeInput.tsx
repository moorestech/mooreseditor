import { NumberInput } from "@mantine/core"
import { IntInput } from "./IntInput"
import { BooleanInput } from "./BooleanInput"
import { StringInput } from "./StringInput"
import { EnumInput } from "./EnumInput"
import { VectorInput } from "./VectorInput"
import { ArrayInput } from "./ArrayInput"
import { DataSchema } from "~/schema"
import { ForeignKeyInput } from "./ForeignKeyInput"
import { useOutletContext } from "@remix-run/react"
import { useMasterDirectory } from "~/hooks/useMasterDirectory"

interface Props {
  showLabel?: boolean;
  property?: string;
  propertySchema: DataSchema;
  value: any;
  onChange(value: unknown): void;
}

export function PrimitiveTypeInput({ showLabel = false, property, propertySchema, value, onChange }: Props) {
  const context = useOutletContext<{ master: ReturnType<typeof useMasterDirectory> }>()
  const label = showLabel ? property : undefined
  const props = {
    label,
    value: value ?? (propertySchema && 'default' in propertySchema ? propertySchema['default'] : undefined),
  }
  if ('enum' in propertySchema) {
    return <EnumInput {...props} data={propertySchema.enum.map(value => String(value))} onChange={onChange} />
  } else if ('autoGenerated' in propertySchema && propertySchema.autoGenerated) {
    return <>自動生成</>
  } else if ('foreignKey' in propertySchema) {
    const [schemaId,tableName, idPropName, labelPropName] = propertySchema.foreignKey.split(':')
    return <ForeignKeyInput
      {...props}
      data={(context.master.getEntries(schemaId))?.[tableName].map((row: any) => ({
        value: row[idPropName],
        label: row[labelPropName]
      }))}
      onChange={onChange}
    />
  } else {
    switch (propertySchema.type) {
      case 'integer':
        return <IntInput {...props} w={160} onChange={onChange} />
      case 'number':
        return <NumberInput {...props} w={160} onChange={onChange} />
      case 'boolean':
        return <BooleanInput {...props} onChange={onChange} />
      case 'string':
        return <StringInput {...props} w={160} onChange={e => onChange(e.currentTarget.value)} />
      case 'array':
        switch (propertySchema.pattern) {
          case '@vector2':
            return <VectorInput dimensions={2} step={1} {...props} onChange={onChange} />
          case '@vector3':
            return <VectorInput dimensions={3} step={1} {...props} onChange={onChange} />
          case '@vector4':
            return <VectorInput dimensions={4} step={1} {...props} onChange={onChange} />
          case '@vector2Int':
            return <VectorInput dimensions={2} step={1} {...props} onChange={onChange} />
          case '@vector3Int':
            return <VectorInput dimensions={3} step={1} {...props} onChange={onChange} />
          case '@vector4Int':
            return <VectorInput dimensions={4} step={1} {...props} onChange={onChange} />
          default:
            return <ArrayInput propertySchema={propertySchema} value={value ?? []} label={label} onChange={(values: any) => onChange(values)} />
        }
      default:
        null
    }

  }
}
